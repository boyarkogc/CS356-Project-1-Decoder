/*
 * transposition-decr.cpp
 *
 *  Created on: Feb 11, 2015
 *      Author: Greg
 */
#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>

using namespace std;
string k1;
string k2;
string textfile;
string plaintext;

bool removeChar(char c) {//
	if (isalpha(c)) {
		return false;
	}
	return true;
}
string parseKey(string key) {
	string tempkey = "";
	size_t found;
	int keyLength = key.length();

	for (int i = 0; i < keyLength; i++) {
		found = tempkey.find(key[i]);
		if (found == string::npos && isalpha(key[i])) {
			tempkey += key[i];
		}
	}
	transform(tempkey.begin(), tempkey.end(),tempkey.begin(), ::toupper);
	cout << tempkey.substr(0,10);
	return tempkey.substr(0,10);
}
bool readPlaintext(string textfile) {
	string line;
	ifstream myfile(textfile.c_str());
	if (myfile.is_open()) {
		while (getline(myfile,line)) {
			plaintext += line;
	    }
		myfile.close();
	}else {
		return false;
	}
	return true;
}
string encrypt(string k1, string k2, string plaintext) {
	string tempkey;//used to store sorted k1 or k2
	size_t index;//used to sort k1 or k2 alphabetically
	string ciphertext1;//string to store ciphertext generated by k1
	string ciphertext2;//string to store ciphertext generated by k2
	int length;//used to indicate length of plaintext or ciphertext

	//strip plaintext of all non-alphanumeric characters, convert to upper-case, and append Xs to end for padding
	//this is to convert the plaintext into a form that can be converted into a ciphertext
	plaintext.erase(remove_if(plaintext.begin(), plaintext.end(), removeChar), plaintext.end());
	transform(plaintext.begin(), plaintext.end(), plaintext.begin(), ::toupper);
	while (plaintext.length() % 10 != 0) {
		plaintext += "X";
	}

	length = plaintext.length();
	tempkey = k1;
	sort(tempkey.begin(), tempkey.end());
	for (int i = 0; i < 10; i++) {
		index = k1.find(tempkey[i]);
		for (int j = index; j < length; j+=10) {
			ciphertext1 += plaintext[j];
		}
	}

	length = ciphertext1.length();
	tempkey = k2;
	sort(tempkey.begin(), tempkey.end());
	for (int i = 0; i < 10; i++) {
		index = k2.find(tempkey[i]);
		for (int j = index; j < length; j+=10) {
			ciphertext2 += ciphertext1[j];
		}
	}

	cout << plaintext << '\n';
	cout << ciphertext1 << '\n';
	cout << ciphertext2 << '\n';
	return ciphertext2;
}


int main() {
	string parseTemp;

	//Ask user for first key and sanitize that key
	cout << "Please enter a 10 character key. The key must contain only letters from the "
		  "English alphabet and must not contain duplicate characters.\n";
	cin >> k1;
	parseTemp = parseKey(k1);
	while (parseTemp.length() < 10) {
		cout << "The key must be at least 10 characters long. The key must contain only letters from the "
		  "English alphabet and must not contain duplicate characters. Please enter a valid key.\n";
		cin >> k1;
		parseTemp = parseKey(k1);
	}
	k1 = parseTemp;

	//Ask user for second key and sanitize that key
	cout << "First key accepted.\n" << "Now please enter a second key, satisfying the same criteria.\n";
	cin >> k2;
	parseTemp = parseKey(k2);
	while (parseTemp.length() < 10) {
		cout << "The key must be at least 10 characters long. The key must contain only letters from the "
		  "English alphabet and must not contain duplicate characters. Please enter a valid key.\n";
		cin >> k2;
		parseTemp = parseKey(k2);
	}
	k2 = parseTemp;

	//ask user for filename containing plaintext
	cout << "Second key accepted\n" << "Now please enter the name of a text file to be encrypted.\n";
	cin >> textfile;
	if (readPlaintext(textfile)) {
		cout << plaintext <<'\n';
	}

	//generate ciphertext using the 2 keys and the plaintext, and store it in file called Greg-Boyarko-encrypted-str.txt
	ofstream outputFile ("Greg-Boyarko-encrypted-str.txt");
	if (outputFile.is_open()) {
		outputFile << encrypt(k1, k2, plaintext) << '\n';
		outputFile.close();
	}else {
		cout << "Unable to open file" << '\n';
	}
}
